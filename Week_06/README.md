# 第六周笔记

## 动态规划与分治

动态规划的名字更直白一些说是动态递推，通过递推的方式将复杂的问题拆解为多个简单的子问题。

它和分治的区别是，它存在最优子结构，在递归过程中只需要把最优的子结果保存下来，来推导出最后最优的结果，而在过程中会不断把次优的结果淘汰掉。

如果问题没有最优子结构，那么就需要递归所有的情况并且记下所有的过程结果，来最后用来推导结果。即为分治。

共性：找到重复子问题。

差异性：最优子结构、中途可以淘汰次优解。

## 动态规划的一般流程

动态规划的三步走：

    1. 暴力解 : 遍历所有子问题

    2. 暴力解加缓存 : 对重复的子问题进行结果保存

    3. 将暴力解加缓存的自顶向下方式改为自下向上方式 : 一般可以达到将递归结构变为迭代结构

即递归（自顶向下）、递推（自底向上）

## 分解子问题实例：

问从起点走到另一个点有多少种走法，那么子问题就是看起点可以到的位置，从那几个位置到终点有多少种走法，然后从起点的走法就是从那几个位置到终点走法的和。就可以写出一个递推公式。

## 最核心的点

对一般较简单的dp问题，定义过程中的状态最重要，状态定义对了才可以做出题目，且状态定义不同，解决问题的方程和难度不同；

对复杂的dp问题，在定义好状态后，找到递推公式也就是dp方程也会比较难找，递推方程的要求是由"最近""最优"的状态进行当前状态推理。

且要注意遍历次序，当前状态一定是由已经求出的过去状态来推理，而不能包含任何未来状态。

### 一些常规套路记录

    1. 字符串匹配问题初步定义一个二维数组，dp[i][j]对应str1的前i个位置的字符串和str2的前j个位置的字符串之间的状态。


