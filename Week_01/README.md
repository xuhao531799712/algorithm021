#三者复杂度分析
数组array：头部插入O(n)，尾部插入O(n)，随机访问O(1)，增加O(n)，删除O(n)
链表linked list：头部插入O(1)，尾部插入O(1)，随机访问O(n)，增加O(1)，删除O(1)
跳表skip list：头部插入O(1)，尾部插入O(1)，随机访问O(logn)，增加O(logn)，删除O(logn)
注意：正常情况下数组array的同步插入和尾部插入的确是O(n)的时间复杂度，但是可以进行特殊优化到O(1)，采用的方式是申请稍大一些的内存空间，在数组的最开始和最末尾预留一部分空间
？跳表的增加和删除操作为什么是O(logn)复杂度呢

#跳表
![avatar](https://github.com/xuhao531799712/algorithm021/blob/main/Week_01/skip-list.png)
![avatar](https://github.com/xuhao531799712/algorithm021/blob/main/Week_01/skip-list2.png)
跳表只能用于元素有序的情况（链表中），对标的是平衡树和二分查找。

插入、删除、搜索都为O(logn)复杂度的操作。

原理简单、容易实现、方便拓展、效率更高。因此在一些热门的项目里用来代替平衡树，如Redis、LevelDB等。

跳表相对于平衡树出现得更早更新，所以很多老的项目中使用平衡树多，而新的一些项目尤其是元素不多的情况下大都是使用跳表。

证明一下时间复杂度：logn实际说的是跳表的高度，也就是索引等级，一般跳表的最高级索引只留两个结点，也就是通过原始链表的结点个数可以得到索引的深度。搜索过程从最大索引开始，依次向下，过程就跟二分查找一模一样。

通常采用升维的方式来进行优化，升维后会多出一级的信息，利用这些信息可以对访问过程进行优化。

思想：升维思想+空间换时间

跳表在实际使用的时候，由于增删操作，会使得跳表跳跃的跨度变得不工整。而且增删操作后需要重新维护索引，使得增加删除操作也变为O(logn)。

跳表的时间占用（每两个结点抽一个）为 n+n/2+n/4+n/8+.....==2n，所以空间复杂度为O(n)。

redis当中使用了跳表，LRU缓存使用了链表。
扩展文献：
https://redisbook.readthedocs.io/en/latest/internal-datastruct/skiplist.html
https://www.zhihu.com/question/20202931


#思考栈、队列等应用场景
问题：什么样的问题可以用栈来解决？
答：具有最近相关性的题目可以用栈来解决。
