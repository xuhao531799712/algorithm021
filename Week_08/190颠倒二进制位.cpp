// 方法一：诸位操作，循环
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t res = 0;
        for (int i = 0; i < 32; ++i) {
            res <<= 1;
            res += (n & 1);
            n >>= 1;
        }
        return res;
    }
};

// 方法二：不使用循环，分治思想
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        // 先相邻1位交换，再相邻2位交换，再相邻4位交换，再相邻8位交换，再相邻16位交换
        n = ((0b10101010101010101010101010101010 & n) >> 1) | ((0b01010101010101010101010101010101 & n) << 1);
        n = ((0b11001100110011001100110011001100 & n) >> 2) | ((0b00110011001100110011001100110011 & n) << 2);
        n = ((0b11110000111100001111000011110000 & n) >> 4) | ((0b00001111000011110000111100001111 & n) << 4);
        n = ((0b11111111000000001111111100000000 & n) >> 8) | ((0b00000000111111110000000011111111 & n) << 8);
        n = (n >> 16) | (n << 16);
        return n;
    }
};
// 化简二进制数
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        // 先相邻1位交换，再相邻2位交换，再相邻4位交换，再相邻8位交换，再相邻16位交换
        // 以上顺序可以任意变换
        n = ((0xaaaaaaaa & n) >> 1) | ((0x55555555 & n) << 1);
        n = ((0xcccccccc & n) >> 2) | ((0x33333333 & n) << 2);
        n = ((0xf0f0f0f0 & n) >> 4) | ((0xf0f0f0f & n) << 4);
        n = ((0xff00ff00 & n) >> 8) | ((0x0ff00ff & n) << 8);
        n = (n >> 16) | (n << 16);
        return n;
    }
};